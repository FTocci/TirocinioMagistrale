<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js</title>
    <style>
        body { margin: 0; }
         button {
            position: absolute;
            z-index: 1;
            background-color: gray;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <button id="zoomButtonIn" style="top: 10px; left: 10px;">Zoom Z</button>
    <button id="zoomButtonOut" style="top: 10px; left: 120px;">De-Zoom Z</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variabili globali
        var scene, camera, renderer, transparentSphere, isRotating = false, sphereClicked = false;
		var livelli = [], nodes, scaleFactor = 1, colorCounter=0, colorNodes = [], colorTextures = [], colorLines = [];
		var initial = true;
		var stageArray = [];
		var clickCoordinates = [];
		var stage = [];
		var stageCounter = 0;
		var stagePrecedente, riga;
		var mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, depthWrite: true })
		var geometry, geometry2, geometry3, geometry4, geometryClick, material, materialClick;
		var mixers =[];
		
		var rowCounter = 0; 
		 
        // Funzione per inizializzare la scena
        function init() {
            // Creiamo una scena
            scene = new THREE.Scene();
			scene.background = new THREE.TextureLoader().load( "textures/planetgalaxybackround.jpg" );
			
			var lontananza = 12;
            // Creiamo una telecamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, lontananza+8);
            camera.position.z = lontananza;
			camera.position.y = 3;
			camera.lookAt(0,0,0);
			camera.zoom = 1.9;
			camera.updateProjectionMatrix();

            // Creiamo un renderizzatore
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
			
			//-------------------------------------------CREAZIONE TEXTURE COLORI--------------------------------------------------
			var textureLoader = new THREE.TextureLoader();
			colorTextures[0]= textureLoader.load("textures/BlueTexture.jpg");
			colorTextures[1]= textureLoader.load("textures/LightBlueTexture.jpg");
			colorTextures[2]= textureLoader.load("textures/GreenTexture.jpg");
			colorTextures[3]= textureLoader.load("textures/YellowTexture.jpg");
			colorTextures[4]= textureLoader.load("textures/RedTexture.jpg");
			
			colorNodes[0] = new THREE.MeshLambertMaterial({ color: 0x2D047F });
			colorNodes[1] = new THREE.MeshLambertMaterial({ color: 0x00363E });
			colorNodes[2] = new THREE.MeshLambertMaterial({ color: 0x013F01 });
			colorNodes[3] = new THREE.MeshLambertMaterial({ color: 0x3C3302 });
			colorNodes[4] = new THREE.MeshLambertMaterial({ color: 0x621E00 });
			
			colorLines[0] = new THREE.LineBasicMaterial({ color: 0x2D047F, opacity: 0.75});
			colorLines[1] = new THREE.LineBasicMaterial({ color: 0x00363E, opacity: 0.75});
			colorLines[2] = new THREE.LineBasicMaterial({ color: 0x013F01, opacity: 0.75});
			colorLines[3] = new THREE.LineBasicMaterial({ color: 0x3C3302, opacity: 0.75});
			colorLines[4] = new THREE.LineBasicMaterial({ color: 0x621E00, opacity: 0.75});


			//--------------------------------------------SFERA TRASPARENTE--------------------------------------------------------
            // Creiamo una sfera da posizionare al centro della scena
			geometry = new THREE.SphereGeometry(1.8, 32, 32);
			geometry2 = new THREE.SphereGeometry(1.79, 32, 32);
			geometry3 = new THREE.SphereGeometry(1.78, 32, 32);
			geometry4 = new THREE.SphereGeometry(1.81, 32, 32);
			geometryClick = new THREE.SphereGeometry(2, 8, 8);

			// Creiamo un materiale trasparente
			material = new THREE.MeshBasicMaterial({
				color: 0xffffff,
				transparent: true, // Imposta il materiale come trasparente
				opacity: 0.1, // Imposta il livello di opacità desiderato (0 = completamente trasparente, 1 = opaco)
				depthWrite: true // Impedisci che oggetti dietro la sfera siano nascosti
			});
			materialClick = new THREE.MeshBasicMaterial({
				color: 0xff0000,
				transparent: true, // Imposta il materiale come trasparente
				opacity: 0, // Imposta il livello di opacità desiderato (0 = completamente trasparente, 1 = opaco)
				depthWrite: true // Impedisci che oggetti dietro la sfera siano nascosti
			});

			// Creiamo la mesh della sfera utilizzando il materiale
			transparentSphere = new THREE.Mesh(geometry, material);	
			transparentSphere2 = new THREE.Mesh(geometry2, material);			
			transparentSphere3 = new THREE.Mesh(geometry3, material);			
			transparentSphere4 = new THREE.Mesh(geometry4, material);		
			sphereClick = new THREE.Mesh(geometryClick, materialClick);	
			
			scene.add(transparentSphere);
			scene.add(transparentSphere2);
			scene.add(transparentSphere3);
			scene.add(transparentSphere4);
			scene.add(sphereClick);			
			
			//----------------------------------LUCI-------------------------------------------------------------------------------
			// Aggiungi una luce ambientale per illuminare la scena
			var ambientLight = new THREE.AmbientLight(0x404040);
			scene.add(ambientLight);

			// Crea una luce direzionale
			var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(5, 10, 1);
			scene.add(directionalLight);
			
			//---------------------------------GRAFO--------------------------------------------------------------------------------
            // Creazione del grafo
            var nodeGeometry = new THREE.SphereGeometry(0.025, 6, 6); // Nodo del grafo
			var nodeMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });

			// Numero di nodi da generare
			var numNodes = 1600;
			nodes = [];
			var lines = [];
			
			// Creazione dei nodi
			for (var i = 0; i < numNodes; i++) {
				var node = new THREE.Mesh(nodeGeometry, nodeMaterial);
				var position = generateRandomCoordinates(1.8);
				node.position.set(position.x, position.y, position.z);
				nodes.push(node);
			}
			
			// Aggiungi i nodi alle sfera principale
			for (var i = 0; i < numNodes; i++) {
				if(i %4 === 0) transparentSphere.add(nodes[i]);
				if(i %4 === 1) transparentSphere2.add(nodes[i]);	
				if(i %4 === 2) transparentSphere3.add(nodes[i]);	
				if(i %4 === 3) transparentSphere4.add(nodes[i]);	
			}
			
			creaArchi(nodes,0.3);
			initial=false;
			//-----------------------------------ASSEGNAZIONE IN ARRAY--------------------------------------------------------------
			stage[0]= [transparentSphere, transparentSphere2, transparentSphere3, transparentSphere4, sphereClick, generaNucleo(transparentSphere)];
			stageArray[stageCounter] = stage;
			
			//-----------------------------------ANIMAZIONI----------------------------------------------------------------
			
			// Gestione del click sulla sfera
			window.addEventListener('mousedown', (event) => {
				const mouse = new THREE.Vector2();
				const raycaster = new THREE.Raycaster();

				// Calcola le coordinate del mouse
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

				// Imposta il raycaster
				raycaster.setFromCamera(mouse, camera);

				// Trova gli oggetti intersecati dal raycaster
				const intersects = raycaster.intersectObjects(scene.children, true);
				
				// Verifica se la sfera è stata cliccata
				for(var t=0; t < stage.length; t++){
					if (intersects.length > 0 && intersects[0].object === (stage[t])[4]) {
						clickCoordinates[0] = (stage[t])[4].position.x;
						clickCoordinates[1] = (stage[t])[4].position.y;
						sphereClicked = true;
						scaleFactor=1;
						
						colorCounter++;
						stage = [];
						stageCounter++;
						updateScene(2);
						stagePrecedente = stageArray[stageCounter-1];
						
						for(var i = 0; i<stagePrecedente.length;i++){			//trova sfera clicked
							if(stagePrecedente[i][4].position.x == clickCoordinates[0] && stagePrecedente[i][4].position.y == clickCoordinates[1]){
								riga = i;
								break;
							}
						}
						
						createSphereMixer();
						setTimeout(function() {						
							sphereClicked = false;
						}, 10000);
						
						
					}
				}
			});
			

			//-----------------------------------BOTTONI E FUNZIONALITà----------------------------------------------------
            // Registriamo l'evento per la pressione del tasto "Space"
            document.addEventListener('keydown', function (event) {
                if (event.keyCode === 32) {
                    isRotating = !isRotating;
                }
            });
			// Ottieni il riferimento al bottone
			var zoomButtonIn = document.getElementById("zoomButtonIn");
			var zoomButtonOut = document.getElementById("zoomButtonOut");
			
			var zoomCount=0;
			// Aggiungi un gestore di eventi al bottone
			zoomButtonIn.addEventListener("click", function() {
				// Modifica la posizione Z della telecamera
				var zoomAmount = 1; // Modifica questa quantità come desideri
				camera.position.z -= zoomAmount;
				zoomCount += 1;
			});
			zoomButtonOut.addEventListener("click", function() {
				// Modifica la posizione Z della telecamera
				if(zoomCount>0){
					var zoomAmount = 1; // Modifica questa quantità come desideri
					camera.position.z += zoomAmount;
					zoomCount -= 1;
				}
				
			});

            animate();
        }
		
		function creaArchi(nodes, minDist){
			if(initial)
				var lineMaterial = new THREE.LineBasicMaterial({ color: 0x808080, opacity: 0.75});
			else			
				var lineMaterial = colorLines[colorCounter]; // Colore della linea
			// Aggiungi gli archi alla sfera principale
			for(var i=0; i<nodes.length; i++){
				nodoA = nodes[i];
				for(var j = i+1; j < nodes.length; j++){
					nodoB = nodes[j];
					var dx = nodoA.position.x - nodoB.position.x;
					var dy = nodoA.position.y - nodoB.position.y;
					var dz = nodoA.position.z - nodoB.position.z;
					var distance = dx * dx + dy * dy + dz * dz;
					
					if(nodoA.parent === nodoB.parent && distance <= minDist*minDist){		
						var line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([nodoA.position, nodoB.position]), lineMaterial);
						nodoA.parent.add(line);
					}
				}

			}

		}
		
		function updateScene(nSfere){

			material = new THREE.MeshBasicMaterial({color: 0xffffff,transparent: true, opacity: 0.1, depthWrite: true });
			materialClick = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: true, opacity: 0, depthWrite: true });
			
			for(var r=0;r<nSfere;r++){
				
				var arr=[];
				for(var c=0;c<4;c++){
					arr[c] = new THREE.Mesh(new THREE.SphereGeometry(1.5-(c/100), 32, 32), material);
					arr[c].position.set(clickCoordinates[0],clickCoordinates[1],-0.01);
					addNodes(arr[c], 100, 1.5);
					scene.add(arr[c]);
				} 	
				arr[4] = new THREE.Mesh(geometryClick, materialClick);	
				arr[4].position.set(arr[0].position.x,arr[0].position.y,arr[0].position.z);
				scene.add(arr[4]);
				arr[5] = generaNucleo(arr[0]);
				scene.add(arr[5]);
				stage[r] = arr;
			}
			stageArray[stageCounter]=stage;
		}
		
		function addNodes(sfera, nNodi, raggio){
		
			var sphereNodes=[];
            var nodeGeometry = new THREE.SphereGeometry(0.025, 6, 6); // Nodo del grafo
			var nodeMaterial = colorNodes[colorCounter-1];
			for (var i = 0; i < nNodi; i++) {
				var node = new THREE.Mesh(nodeGeometry, nodeMaterial);
				var position = generateRandomCoordinates(1.5);
				node.position.set(position.x, position.y, position.z);
				sphereNodes.push(node);
				sfera.add(node);
			}
			colorCounter--;
			creaArchi(sphereNodes,0.3);
			colorCounter++;
			
		}
		
		function generaNucleo(sphere){
			var texture = colorTextures[colorCounter];
			var materialSubSphere = new THREE.MeshPhongMaterial({ map: texture })
			
			// Crea una geometria sferica
			var geometrySubSphere = new THREE.SphereGeometry(1.3-0.15*colorCounter, 16, 16);

			// Crea una mesh utilizzando la geometria e il materiale
			nucleo = new THREE.Mesh(geometrySubSphere, materialSubSphere);
			nucleo.position.set(sphere.position.x, sphere.position.y, sphere.position.z);
			scene.add(nucleo);
			
			var nuoviNodi=[];
            var nodeGeometry = new THREE.SphereGeometry(0.025, 6, 6); // Nodo del grafo
			var nodeMaterial = colorNodes[colorCounter];
			for (var i = 0; i < 400; i++) {
				var node = new THREE.Mesh(nodeGeometry, nodeMaterial);
				var position = generateRandomCoordinates(1.3-0.15*colorCounter);
				node.position.set(position.x, position.y, position.z);
				nuoviNodi.push(node);
				nucleo.add(node);
			}
			
			//creaArchi(nuoviNodi,0.3);
			return nucleo;
		}

	

		
		// Creazione delle coordinate
		function generateRandomCoordinates(raggio) {
			var u = Math.random(); // Uniformemente distribuito tra 0 e 1
			var v = Math.random(); // Uniformemente distribuito tra 0 e 1

			var theta = 2 * Math.PI * u; // Angolo orizzontale da 0 a 2π
			var phi = Math.acos(2 * v - 1); // Angolo verticale da 0 a π 
				
			var x = Math.sin(phi) * Math.cos(theta); // Calcolo delle coordinate sferiche
			var y = Math.sin(phi) * Math.sin(theta);
			var z = Math.cos(phi);

			// Moltiplica per il raggio della sfera (1.5)
			var radius = raggio;
			x *= radius;
			y *= radius;
			z *= radius;
			return { x, y, z };
		}
		

		
		function createSphereMixer(){
			for(var m=0;m<stage.length;m++){
					for(var s=0;s<6;s++){
						var mixer = new THREE.AnimationMixer((stage[m])[s]);
						
						const duration = 10;

						// Punto finale (punto B)
						var startPosition = new THREE.Vector3((stage[m])[s].position.x, (stage[m])[s].position.y, (stage[m])[s].position.z);
						var midPosition1 = new THREE.Vector3(0, 0, -5);
						var midPosition2 = new THREE.Vector3(-2, 0, -2);
						var midPosition3 = new THREE.Vector3(-2, 0, 2);
						var endPosition = new THREE.Vector3((m*4), 0, 0);

						// Crea una traccia di animazione per la posizione
						var positionTrack = new THREE.VectorKeyframeTrack('.position', [0, 1, 2, 3, 6], [
							startPosition.x, startPosition.y, startPosition.z, // Punto A
							midPosition1.x, midPosition1.y, midPosition1.z,       // Punto intermedio 1
							midPosition2.x, midPosition2.y, midPosition2.z,       // Punto intermedio 2
							midPosition3.x, midPosition3.y, midPosition3.z,       // Punto intermedio 3
							endPosition.x, endPosition.y, endPosition.z            // Punto B
						]);
						// Crea la clip di animazione utilizzando la traccia di posizione
						var clip = new THREE.AnimationClip('move', duration, [positionTrack]);

						// Aggiungi la clip all'oggetto AnimationMixer
						var action = mixer.clipAction(clip);

						// Avvia l'animazione
						action.play();
						mixers.push(mixer);
					}
				}
		}

        // Funzione per animare la scena
        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                // Ruotiamo le sfere solo se isRotating è true
				/* VERSIONE CHE UTILIZZA FUNZIONE SENO E FUNZIONE MODULO
					- Abs: funzione modulo
					- Date().getTime(): fornisce timestamp
					- /2500 determina quanto l'oscillazione varia velocemente (maggiore è il numero, meno è rapida la variazione)
					- /500: [0,1] --> [0,0.002]*/
				for(var r=0;r<stage.length;r++){
					(stage[r])[0].rotation.x += (Math.abs(Math.sin(new Date().getTime() / 2750)))/500;
					(stage[r])[0].rotation.y += 0.004;

					(stage[r])[1].rotation.x += (Math.abs(Math.sin(new Date().getTime() / 3000)))/500;
					(stage[r])[1].rotation.y += 0.005;

					(stage[r])[2].rotation.x += (Math.abs(Math.sin(new Date().getTime() / 3250)))/500;
					(stage[r])[2].rotation.y += 0.006;
						
					(stage[r])[3].rotation.x += (Math.abs(Math.sin(new Date().getTime() / 3500)))/500;
					(stage[r])[3].rotation.y += 0.007;
					
					(stage[r])[5].rotation.x += (Math.abs(Math.sin(new Date().getTime() / 3500)))/500;
					(stage[r])[5].rotation.y += 0.007;
				}
				
            }
			
			if(sphereClicked){
				scaleFactor+=0.0012;
				
				for(var y=0;y<stagePrecedente.length;y++){				//rimozione sfere notClicked
					if(y!=riga){
						scene.remove((stagePrecedente[y])[0]);
						scene.remove((stagePrecedente[y])[1]);
						scene.remove((stagePrecedente[y])[2]);
						scene.remove((stagePrecedente[y])[3]);
						scene.remove((stagePrecedente[y])[4]);
						scene.remove((stagePrecedente[y])[5]);
					}
				}
				
				for(var k=0;k<stagePrecedente[riga].length-1;k++){					//esplosione sfera clicked
					s=stagePrecedente[riga][k];
					
					for(var z=0;z<s.children.length;z++){
						var child=s.children[z];
						if(child.geometry.type == "SphereGeometry"){
							child.scale.set(child.scale.x-0.004,child.scale.y-0.004,child.scale.z-0.004);								
						}
					}
					s.material.opacity -= 0.00012;
					s.scale.x += 0.075;
					s.scale.y += 0.075;
					s.scale.z += 0.075;
					if(s.material.opacity<0) scene.remove(s);						

				}
				scene.remove(stagePrecedente[riga][5]);					

				/*for(var m=0;m<stage.length;m++){
					for(var s=0;s<6;s++){
						if(m%2==0)
							makeSphereMovement((stage[m])[s],0.01);
						else
							makeSphereMovement((stage[m])[s],-0.01);
					}
				}*/
				
				for(var mix=0;mix<mixers.length;mix++){
					mixers[mix].update(0.01);
				}
				
                

				
			}
            renderer.render(scene, camera);
        }

		
		// Ridimensionamento della finestra
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });
		

        // Inizializziamo la scena
        init();
    </script>
</body>
</html>
