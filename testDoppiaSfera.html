<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js</title>
    <style>
        body { margin: 0; }
         button {
            position: absolute;
            z-index: 1;
            background-color: gray;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <button id="zoomButtonIn" style="top: 10px; left: 10px;">Zoom Z</button>
    <button id="zoomButtonOut" style="top: 10px; left: 120px;">De-Zoom Z</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variabili globali
        var scene, camera, renderer, transparentSphere, isRotating = false, sphereClicked = false, subSphere, nodes, scaleFactor = 1;
        // Funzione per inizializzare la scena
        function init() {
            // Creiamo una scena
            scene = new THREE.Scene();
			scene.background = new THREE.TextureLoader().load( "textures/planetgalaxybackround.jpg" );
			
			var lontananza = 10;
            // Creiamo una telecamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = lontananza;
			camera.zoom = 1.9;
			camera.updateProjectionMatrix();

            // Creiamo un renderizzatore
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

			//--------------------------------------------SFERA TRASPARENTE--------------------------------------------------------
            // Creiamo una sfera da posizionare al centro della scena
			var geometry = new THREE.SphereGeometry(1.5, 32, 32);
			var geometry2 = new THREE.SphereGeometry(1.49, 32, 32);
			var geometry3 = new THREE.SphereGeometry(1.48, 32, 32);
			var geometry4 = new THREE.SphereGeometry(1.51, 32, 32);
			var geometryClick = new THREE.SphereGeometry(1.7, 32, 32);

			// Creiamo un materiale trasparente
			var material = new THREE.MeshBasicMaterial({
				color: 0xffffff,
				transparent: true, // Imposta il materiale come trasparente
				opacity: 0.1, // Imposta il livello di opacità desiderato (0 = completamente trasparente, 1 = opaco)
				depthWrite: true // Impedisci che oggetti dietro la sfera siano nascosti
			});
			var materialClick = new THREE.MeshBasicMaterial({
				color: 0xffffff,
				transparent: true, // Imposta il materiale come trasparente
				opacity: 0, // Imposta il livello di opacità desiderato (0 = completamente trasparente, 1 = opaco)
				depthWrite: true // Impedisci che oggetti dietro la sfera siano nascosti
			});

			// Creiamo la mesh della sfera utilizzando il materiale
			transparentSphere = new THREE.Mesh(geometry, material);			
			transparentSphere2 = new THREE.Mesh(geometry2, material);			
			transparentSphere3 = new THREE.Mesh(geometry3, material);			
			transparentSphere4 = new THREE.Mesh(geometry4, material);			
			sphereClick = new THREE.Mesh(geometryClick, materialClick);	
			
			scene.add(transparentSphere);
			scene.add(transparentSphere2);
			scene.add(transparentSphere3);
			scene.add(transparentSphere4);
			scene.add(sphereClick);
			
			//-----------------------------------SFERA NUCLEO-----------------------------------------------------------------------
			// Crea un materiale verde scuro
			//var materialSubSphere = new THREE.MeshPhongMaterial({ color: 0x006400 }); // Colore verde scuro
			
			var textureLoader = new THREE.TextureLoader();
			var texture = textureLoader.load("textures/greenTexture.jpg");
			var materialSubSphere = new THREE.MeshPhongMaterial({ map: texture })
			
			// Crea una geometria sferica
			var geometrySubSphere = new THREE.SphereGeometry(1, 16, 16);

			// Crea una mesh utilizzando la geometria e il materiale
			subSphere = new THREE.Mesh(geometrySubSphere, materialSubSphere);
			subSphere.position.set(transparentSphere.position.x, transparentSphere.position.y, transparentSphere.position.z);
			scene.add(subSphere);
			
			//----------------------------------SFERE EXTRA------------------------------------------------------------------------
			// Crea un materiale verde scuro
			var materialSphere2 = new THREE.MeshPhongMaterial({ color: 0x006400 }); // Colore verde scuro

			// Crea una geometria sferica
			var geometrySphere2 = new THREE.SphereGeometry(1, 32, 32);

			// Crea una mesh utilizzando la geometria e il materiale
			var Sphere2 = new THREE.Mesh(geometrySphere2, materialSphere2);
			Sphere2.position.set(-4,2, 0);
			scene.add(Sphere2);

			// Crea una mesh utilizzando la geometria e il materiale
			var Sphere2 = new THREE.Mesh(geometrySphere2, materialSphere2);
			Sphere2.position.set(4,-2, 0);
			scene.add(Sphere2);
			
			//----------------------------------LUCI-------------------------------------------------------------------------------
			// Aggiungi una luce ambientale per illuminare la scena
			var ambientLight = new THREE.AmbientLight(0x404040);
			scene.add(ambientLight);

			// Crea una luce direzionale
			var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(5, 10, 1);
			scene.add(directionalLight);
			
			//---------------------------------GRAFO--------------------------------------------------------------------------------
            // Creazione del grafo
            var nodeGeometry = new THREE.SphereGeometry(0.025, 6, 6); // Nodo del grafo
			var nodeMaterial = new THREE.MeshLambertMaterial({ color: 0x00AA00 });
            var nodeMaterial2 = new THREE.MeshLambertMaterial({ color: 0xffffff });
            var lineMaterial = new THREE.LineBasicMaterial({ color: 0x006400, opacity: 0.75}); // Colore della linea

			// Numero di nodi da generare
			var numNodes = 1600;
			nodes = [];
			var lines = [];

			// Creazione delle coordinate
			function generateRandomCoordinates(raggio) {
				var u = Math.random(); // Uniformemente distribuito tra 0 e 1
				var v = Math.random(); // Uniformemente distribuito tra 0 e 1

				var theta = 2 * Math.PI * u; // Angolo orizzontale da 0 a 2π
				var phi = Math.acos(2 * v - 1); // Angolo verticale da 0 a π
				 
				
				var x = Math.sin(phi) * Math.cos(theta); // Calcolo delle coordinate sferiche
				var y = Math.sin(phi) * Math.sin(theta);
				var z = Math.cos(phi);

				// Moltiplica per il raggio della sfera (1.5)
				var radius = raggio;
				x *= radius;
				y *= radius;
				z *= radius;

				return { x, y, z };
			}
			
			// Creazione dei nodi
			for (var i = 0; i < numNodes; i++) {
				var node = new THREE.Mesh(nodeGeometry, nodeMaterial);
				var position = generateRandomCoordinates(1.5);
				node.position.set(position.x, position.y, position.z);
				nodes.push(node);
			}
			
			// Aggiungi i nodi alle sfera principale
			for (var i = 0; i < numNodes; i++) {
				if(i %4 === 0) transparentSphere.add(nodes[i]);
				if(i %4 === 1) transparentSphere2.add(nodes[i]);	
				if(i %4 === 2) transparentSphere3.add(nodes[i]);	
				if(i %4 === 3) transparentSphere4.add(nodes[i]);	
			}
			
			creaArchi(nodes,0.3);
			
			//-----------------------------------ANIMAZIONI----------------------------------------------------------------
			
			// Gestione del click sulla sfera
			window.addEventListener('mousedown', (event) => {
				const mouse = new THREE.Vector2();
				const raycaster = new THREE.Raycaster();

				// Calcola le coordinate del mouse
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

				// Imposta il raycaster
				raycaster.setFromCamera(mouse, camera);

				// Trova gli oggetti intersecati dal raycaster
				const intersects = raycaster.intersectObjects(scene.children, true);

				// Verifica se la sfera è stata cliccata
				if (intersects.length > 0 && intersects[0].object === sphereClick) {//ciclo che genera questa parte e scorre le sphere click
					console.log('Sfera cliccata!');
					sphereClicked = true;

					var mat = new THREE.MeshBasicMaterial({
						color: 0xffffff,
						transparent: true, // Imposta il materiale come trasparente
						opacity: 0.2, // Imposta il livello di opacità desiderato (0 = completamente trasparente, 1 = opaco)
						depthWrite: true // Impedisci che oggetti dietro la sfera siano nascosti
					});
					subSphere.material=mat;

					var nuoviNodi=[];
					for (var i = 0; i < 800; i++) {
						var node = new THREE.Mesh(nodeGeometry, nodeMaterial);
						var position = generateRandomCoordinates(1);
						node.position.set(position.x, position.y, position.z);
						nuoviNodi.push(node);
						subSphere.add(node);
					}
					console.log(nuoviNodi);
					
					
					creaArchi(nuoviNodi,0.15);
					setTimeout(function() {
						sphereClicked = false;
					}, 4000);
					
				}
			});
			

			//-----------------------------------BOTTONI E FUNZIONALITà----------------------------------------------------
            // Registriamo l'evento per la pressione del tasto "Space"
            document.addEventListener('keydown', function (event) {
                if (event.keyCode === 32) {
                    isRotating = !isRotating;
                }
            });
			// Ottieni il riferimento al bottone
			var zoomButtonIn = document.getElementById("zoomButtonIn");
			var zoomButtonOut = document.getElementById("zoomButtonOut");
			console.log(transparentSphere);
			
			var zoomCount=0;
			// Aggiungi un gestore di eventi al bottone
			zoomButtonIn.addEventListener("click", function() {
				// Modifica la posizione Z della telecamera
				var zoomAmount = 1; // Modifica questa quantità come desideri
				camera.position.z -= zoomAmount;
				zoomCount += 1;
			});
			zoomButtonOut.addEventListener("click", function() {
				// Modifica la posizione Z della telecamera
				if(zoomCount>0){
					var zoomAmount = 1; // Modifica questa quantità come desideri
					camera.position.z += zoomAmount;
					zoomCount -= 1;
				}
				
			});

            animate();
        }
		
		function creaArchi(nodes, minDist){
            var lineMaterial = new THREE.LineBasicMaterial({ color: 0x006400, opacity: 0.75}); // Colore della linea
			// Aggiungi gli archi alla sfera principale
			for(var i=0; i<nodes.length; i++){
				nodoA = nodes[i];
				for(var j = i+1; j < nodes.length; j++){
					nodoB = nodes[j];
					var dx = nodoA.position.x - nodoB.position.x;
					var dy = nodoA.position.y - nodoB.position.y;
					var dz = nodoA.position.z - nodoB.position.z;
					var distance = dx * dx + dy * dy + dz * dz;
					
					if(nodoA.parent === nodoB.parent && distance <= minDist*minDist){		
						var line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([nodoA.position, nodoB.position]), lineMaterial);
						
						nodoA.parent.add(line);
					}
				}

			}
		}

        // Funzione per animare la scena
        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                // Ruotiamo le sfere solo se isRotating è true
				/* VERSIONE CHE UTILIZZA FUNZIONE SENO E FUNZIONE MODULO
					- Abs: funzione modulo
					- Date().getTime(): fornisce timestamp
					- /2500 determina quanto l'oscillazione varia velocemente (maggiore è il numero, meno è rapida la variazione)
					- /500: [0,1] --> [0,0.002]
				*/
				transparentSphere.rotation.x += (Math.abs(Math.sin(new Date().getTime() / 2750)))/500;
				transparentSphere.rotation.y += 0.004;

				transparentSphere2.rotation.x += (Math.abs(Math.sin(new Date().getTime() / 3000)))/500;
				transparentSphere2.rotation.y += 0.005;

				transparentSphere3.rotation.x += (Math.abs(Math.sin(new Date().getTime() / 3250)))/500;
				transparentSphere3.rotation.y += 0.006;
				
				transparentSphere4.rotation.x += (Math.abs(Math.sin(new Date().getTime() / 3500)))/500;
				transparentSphere4.rotation.y += 0.007;
				
				//console.log(Math.sin(new Date().getTime() / 3000));
				
				/*	VERSIONE CON VALORI FISSI
					transparentSphere.rotation.x += 0.0050;
					transparentSphere.rotation.y += 0.005;

					transparentSphere2.rotation.x += 0.0047
					transparentSphere2.rotation.y += 0.005;

					transparentSphere3.rotation.x += 0.0053;
					transparentSphere3.rotation.y += 0.005;
				*/
				
                subSphere.rotation.y += 0.01;
            }
			
			var spheres=[transparentSphere,transparentSphere2,transparentSphere3,transparentSphere4,sphereClick]; //per ampliare basta cambiare contenuto array
			if(sphereClicked){
				for(var k=0;k<spheres.length;k++){
					s=spheres[k];
					if (s.position.z > -30) {
						s.position.z -= 0.05;
						s.position.x += 0.05;
						s.position.y += 0.05;
						s.material.opacity -= 0.0004;
						console.log(s.material.opacity);
						if(s.material.opacity<=0)scene.remove(s);
						
					}
				}
				scaleFactor+=0.002;				
				subSphere.scale.set(scaleFactor, scaleFactor, scaleFactor);
			}

            renderer.render(scene, camera);
        }
		
		
		
		// Ridimensionamento della finestra
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });
		

        // Inizializziamo la scena
        init();
    </script>
</body>
</html>
